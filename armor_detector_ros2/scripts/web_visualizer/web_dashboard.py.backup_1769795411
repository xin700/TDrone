#!/usr/bin/env python3
"""Web可视化仪表盘 - ROS2 装甲板检测与预测系统"""
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from armor_detector_ros2.msg import ArmorBBoxArray, OutpostAimResult
from cv_bridge import CvBridge
import cv2
import numpy as np
from flask import Flask, render_template_string, Response, jsonify, request, send_file
from flask_socketio import SocketIO
import threading
import time
import json
from collections import deque
import argparse
import os
import glob

class WebVisualizerNode(Node):
    def __init__(self):
        super().__init__('web_visualizer_node')
        self.bridge = CvBridge()
        
        # 订阅话题
        self.image_sub = self.create_subscription(
            Image, '/detector/image_with_stamp', self.image_callback, 10)
        self.armors_sub = self.create_subscription(
            ArmorBBoxArray, '/detector/armors', self.armors_callback, 10)
        self.aim_sub = self.create_subscription(
            OutpostAimResult, '/predictor_v4/aim_result', self.aim_callback, 10)
        
        # 数据存储
        self.latest_frame = None
        self.latest_armors = None
        self.latest_aim_result = None
        self.frame_lock = threading.Lock()
        
        # 时间序列数据（最近100个点）
        self.aim_history = {
            'time': deque(maxlen=100),
            'x': deque(maxlen=100), 'y': deque(maxlen=100), 'z': deque(maxlen=100),
            'theta': deque(maxlen=100), 'omega': deque(maxlen=100)
        }
        
        self.get_logger().info('Web Visualizer Node 已启动')
    
    def image_callback(self, msg):
        try:
            frame = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
            # 绘制完整的可视化信息
            frame = self.draw_visualization(frame)
            with self.frame_lock:
                self.latest_frame = frame
        except Exception as e:
            self.get_logger().error(f'图像处理错误: {e}')
    
    def armors_callback(self, msg):
        self.latest_armors = msg
    
    def aim_callback(self, msg):
        self.latest_aim_result = msg
        # 记录时间序列数据
        t = time.time()
        self.aim_history['time'].append(t)
        self.aim_history['x'].append(msg.aim_position.x)
        self.aim_history['y'].append(msg.aim_position.y)
        self.aim_history['z'].append(msg.aim_position.z)
        self.aim_history['theta'].append(msg.observed_theta)
        self.aim_history['omega'].append(msg.omega)
    
    def draw_visualization(self, frame):
        """绘制完整的可视化信息（类似visualizer_node_v4）"""
        if self.latest_armors is None:
            return frame
        
        # 绘制装甲板
        for armor in self.latest_armors.armors:
            # 颜色映射：0=蓝色, 1=红色, 2=灰色, 3=紫色
            if armor.color_id == 0:  # BLUE
                color = (255, 0, 0)
            elif armor.color_id == 1:  # RED
                color = (0, 0, 255)
            else:
                color = (128, 128, 128)
            
            # 绘制四个角点
            for corner in armor.corners:
                pt = (int(corner.x), int(corner.y))
                cv2.circle(frame, pt, 4, color, -1)
            
            # 绘制中心点
            center = (int(armor.center.x), int(armor.center.y))
            cv2.circle(frame, center, 5, color, -1)
            
            # 标注 tag_id
            label = f"ID-{armor.tag_id}"
            cv2.putText(frame, label, (center[0] - 30, center[1] - 15),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
        
        # 绘制预测器状态信息（左上角）
        if self.latest_aim_result is not None:
            aim = self.latest_aim_result
            y = 30
            line_height = 25
            
            # 标题
            cv2.putText(frame, "Predictor V4", (20, y),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
            y += line_height
            
            # EKF状态
            ekf_status = "CONV" if aim.ekf_converged else "INIT"
            color = (0, 255, 0) if aim.ekf_converged else (0, 165, 255)
            cv2.putText(frame, f"EKF: {ekf_status}", (20, y),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
            y += line_height
            
            # 旋转方向
            dir_str = "CW" if aim.rotation_direction == -1 else ("CCW" if aim.rotation_direction == 1 else "STOP")
            cv2.putText(frame, f"Dir: {dir_str}", (20, y),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
            y += line_height
            
            # 观测角theta（度）
            cv2.putText(frame, f"theta: {aim.observed_theta:.1f} deg", (20, y),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
            y += line_height
            
            # 角速度omega
            cv2.putText(frame, f"omega: {aim.omega:.3f} rad/s", (20, y),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)
            y += line_height
            
            # 预瞄点位置
            cv2.putText(frame, f"Aim: ({aim.aim_position.x:.2f}, {aim.aim_position.y:.2f}, {aim.aim_position.z:.2f})",
                       (20, y), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 2)
            y += line_height
            
            # 开火条件
            fire_str = "YES" if aim.fire_condition_1 else "NO"
            fire_color = (0, 255, 0) if aim.fire_condition_1 else (0, 0, 255)
            cv2.putText(frame, f"Fire: {fire_str}", (20, y),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, fire_color, 2)
        
        return frame
    
    def get_frame_jpeg(self):
        """获取JPEG编码的帧"""
        with self.frame_lock:
            if self.latest_frame is None:
                # 返回黑色占位图
                placeholder = np.zeros((480, 640, 3), dtype=np.uint8)
                cv2.putText(placeholder, "Waiting for image...", (200, 240),
                           cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
                _, buffer = cv2.imencode('.jpg', placeholder)
            else:
                _, buffer = cv2.imencode('.jpg', self.latest_frame, 
                                        [cv2.IMWRITE_JPEG_QUALITY, 85])
            return buffer.tobytes()
    
    def get_statistics(self):
        """获取统计数据"""
        if self.latest_armors is None:
            return {'count': 0}
        
        stats = {'count': len(self.latest_armors.armors), 'by_color': {}}
        color_names = {0: 'BLUE', 1: 'RED', 2: 'GRAY', 3: 'PURPLE'}
        for armor in self.latest_armors.armors:
            color_name = color_names.get(armor.color_id, 'UNKNOWN')
            stats['by_color'][color_name] = stats['by_color'].get(color_name, 0) + 1
        
        return stats
    
    def get_predictor_state(self):
        """获取预测器状态"""
        if self.latest_aim_result is None:
            return None
        
        aim = self.latest_aim_result
        return {
            'ekf_converged': aim.ekf_converged,
            'theta': float(aim.observed_theta),
            'omega': float(aim.omega),
            'rotation_direction': int(aim.rotation_direction),
            'fire_condition': aim.fire_condition_1,
            'aim_x': float(aim.aim_position.x),
            'aim_y': float(aim.aim_position.y),
            'aim_z': float(aim.aim_position.z)
        }
    
    def get_time_series(self):
        """获取时间序列数据"""
        if len(self.aim_history['time']) == 0:
            return None
        
        # 计算相对时间（秒）
        times = list(self.aim_history['time'])
        base_time = times[0]
        rel_times = [t - base_time for t in times]
        
        return {
            'time': rel_times,
            'aim_x': list(self.aim_history['x']),
            'aim_y': list(self.aim_history['y']),
            'aim_z': list(self.aim_history['z']),
            'theta': list(self.aim_history['theta']),
            'omega': list(self.aim_history['omega'])
        }


# Flask应用
app = Flask(__name__)
socketio = SocketIO(app, cors_allowed_origins="*")
ros_node = None

def gen_frames():
    """生成视频流"""
    while True:
        if ros_node is None:
            time.sleep(0.1)
            continue
        frame_bytes = ros_node.get_frame_jpeg()
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')
        time.sleep(0.033)  # ~30fps

@app.route('/video_feed')
def video_feed():
    return Response(gen_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/api/stats')
def api_stats():
    if ros_node is None:
        return jsonify({'error': 'ROS node not initialized'})
    return jsonify(ros_node.get_statistics())

@app.route('/api/predictor')
def api_predictor():
    if ros_node is None:
        return jsonify({'error': 'ROS node not initialized'})
    state = ros_node.get_predictor_state()
    return jsonify(state if state else {})

@app.route('/api/timeseries')
def api_timeseries():
    if ros_node is None:
        return jsonify({'error': 'ROS node not initialized'})
    data = ros_node.get_time_series()
    return jsonify(data if data else {})

@app.route('/api/videos')
def api_videos():
    """获取output目录下的视频列表"""
    output_dir = '/home/user/droneAim/TDrone/output'
    if not os.path.exists(output_dir):
        return jsonify({'videos': []})
    
    videos = []
    for ext in ['*.mp4', '*.avi', '*.mkv']:
        for f in glob.glob(os.path.join(output_dir, ext)):
            stat = os.stat(f)
            videos.append({
                'name': os.path.basename(f),
                'path': f,
                'size': stat.st_size,
                'mtime': stat.st_mtime
            })
    
    # 按修改时间降序排序
    videos.sort(key=lambda x: x['mtime'], reverse=True)
    return jsonify({'videos': videos})

@app.route('/api/video/<path:filename>')
def serve_video(filename):
    """提供视频文件下载"""
    output_dir = '/home/user/droneAim/TDrone/output'
    filepath = os.path.join(output_dir, filename)
    if os.path.exists(filepath):
        return send_file(filepath, mimetype='video/mp4')
    return jsonify({'error': 'File not found'}), 404

HTML_TEMPLATE = '''
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>装甲板检测可视化</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: #f5f5f5;
            color: #333;
        }
        .header {
            background: white;
            padding: 15px 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .header h1 {
            font-size: 24px;
            font-weight: 600;
            color: #333;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .panel {
            background: white;
            border-radius: 4px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .panel-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }
        .video-panel {
            flex: 3;
        }
        .stats-panel {
            flex: 1;
            min-width: 250px;
        }
        #videoStream {
            width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
        }
        .stat-item {
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        .stat-label {
            font-size: 13px;
            color: #666;
        }
        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-top: 2px;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }
        .badge-success { background: #e8f5e9; color: #2e7d32; }
        .badge-warning { background: #fff3e0; color: #f57c00; }
        .badge-error { background: #ffebee; color: #c62828; }
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 10px;
        }
        .full-width { flex: 1; }
        .video-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .video-item {
            padding: 10px;
            margin: 5px 0;
            background: #f9f9f9;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .video-item:hover {
            background: #e8e8e8;
        }
        .video-item-name {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }
        .video-item-info {
            font-size: 12px;
            color: #666;
            margin-top: 3px;
        }
        .video-player {
            margin-top: 15px;
        }
        #videoPlayer {
            width: 100%;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>装甲板检测与预测可视化</h1>
    </div>
    
    <div class="container">
        <!-- 第一行：实时画面 + 预测器状态 -->
        <div class="row">
            <div class="panel video-panel">
                <div class="panel-title">实时检测画面</div>
                <img id="videoStream" src="/video_feed" alt="Video Stream">
            </div>
            <div class="panel stats-panel">
                <div class="panel-title">检测统计</div>
                <div class="stat-item">
                    <div class="stat-label">装甲板数量</div>
                    <div class="stat-value" id="armorCount">0</div>
                </div>
                <div class="stat-item" id="colorStats"></div>
                
                <div class="panel-title" style="margin-top: 20px;">预测器状态</div>
                <div class="stat-item">
                    <div class="stat-label">EKF状态</div>
                    <div id="ekfStatus">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">观测角 θ (deg)</div>
                    <div class="stat-value" id="theta">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">角速度 ω (rad/s)</div>
                    <div class="stat-value" id="omega">-</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">开火条件</div>
                    <div id="fireCond">-</div>
                </div>
            </div>
        </div>
        
        <!-- 第二行：预瞄坐标曲线（占满整行）-->
        <div class="row">
            <div class="panel full-width">
                <div class="panel-title">预瞄坐标 (X, Y, Z)</div>
                <div class="chart-container">
                    <canvas id="aimChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- 第三行：角度和角速度曲线 -->
        <div class="row">
            <div class="panel" style="flex: 1;">
                <div class="panel-title">观测角 θ (deg)</div>
                <div class="chart-container">
                    <canvas id="thetaChart"></canvas>
                </div>
            </div>
            <div class="panel" style="flex: 1;">
                <div class="panel-title">角速度 ω (rad/s)</div>
                <div class="chart-container">
                    <canvas id="omegaChart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- 第四行：视频文件浏览和播放 -->
        <div class="row">
            <div class="panel" style="flex: 1;">
                <div class="panel-title">输出视频文件</div>
                <div class="video-list" id="videoList">
                    <div style="color: #999; text-align: center; padding: 20px;">加载中...</div>
                </div>
            </div>
            <div class="panel" style="flex: 2;">
                <div class="panel-title">视频播放器</div>
                <div id="videoPlayerContainer" style="color: #999; text-align: center; padding: 40px;">
                    请从左侧选择视频文件
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // 图表配置
        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { position: 'top' } },
            scales: {
                x: { title: { display: true, text: '时间 (s)' } },
                y: { title: { display: true, text: '值' } }
            }
        };
        
        // 初始化图表
        const aimChart = new Chart(document.getElementById('aimChart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'X (m)', data: [], borderColor: '#f44336', backgroundColor: 'rgba(244, 67, 54, 0.1)', borderWidth: 2 },
                    { label: 'Y (m)', data: [], borderColor: '#4caf50', backgroundColor: 'rgba(76, 175, 80, 0.1)', borderWidth: 2 },
                    { label: 'Z (m)', data: [], borderColor: '#2196f3', backgroundColor: 'rgba(33, 150, 243, 0.1)', borderWidth: 2 }
                ]
            },
            options: commonOptions
        });
        
        const thetaChart = new Chart(document.getElementById('thetaChart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{ label: 'θ', data: [], borderColor: '#ff9800', backgroundColor: 'rgba(255, 152, 0, 0.1)', borderWidth: 2 }]
            },
            options: commonOptions
        });
        
        const omegaChart = new Chart(document.getElementById('omegaChart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{ label: 'ω', data: [], borderColor: '#9c27b0', backgroundColor: 'rgba(156, 39, 176, 0.1)', borderWidth: 2 }]
            },
            options: commonOptions
        });
        
        // 定时更新数据
        setInterval(() => {
            // 更新统计信息
            fetch('/api/stats').then(r => r.json()).then(data => {
                document.getElementById('armorCount').textContent = data.count || 0;
                const colorDiv = document.getElementById('colorStats');
                if (data.by_color) {
                    let html = '';
                    for (const [color, count] of Object.entries(data.by_color)) {
                        html += `<div style="margin: 5px 0;"><span style="color:#666;">${color}:</span> <strong>${count}</strong></div>`;
                    }
                    colorDiv.innerHTML = html;
                }
            });
            
            // 更新预测器状态
            fetch('/api/predictor').then(r => r.json()).then(data => {
                if (data.ekf_converged !== undefined) {
                    const ekfBadge = data.ekf_converged 
                        ? '<span class="status-badge badge-success">已收敛</span>'
                        : '<span class="status-badge badge-warning">初始化</span>';
                    document.getElementById('ekfStatus').innerHTML = ekfBadge;
                    
                    document.getElementById('theta').textContent = data.theta ? data.theta.toFixed(1) : '-';
                    document.getElementById('omega').textContent = data.omega ? data.omega.toFixed(3) : '-';
                    
                    const fireBadge = data.fire_condition
                        ? '<span class="status-badge badge-success">满足</span>'
                        : '<span class="status-badge badge-error">不满足</span>';
                    document.getElementById('fireCond').innerHTML = fireBadge;
                }
            });
            
            // 更新曲线图
            fetch('/api/timeseries').then(r => r.json()).then(data => {
                if (data.time && data.time.length > 0) {
                    const labels = data.time.map(t => t.toFixed(2));
                    
                    aimChart.data.labels = labels;
                    aimChart.data.datasets[0].data = data.aim_x;
                    aimChart.data.datasets[1].data = data.aim_y;
                    aimChart.data.datasets[2].data = data.aim_z;
                    aimChart.update('none');
                    
                    thetaChart.data.labels = labels;
                    thetaChart.data.datasets[0].data = data.theta;
                    thetaChart.update('none');
                    
                    omegaChart.data.labels = labels;
                    omegaChart.data.datasets[0].data = data.omega;
                    omegaChart.update('none');
                }
            });
        }, 500);
        
        // 加载视频列表
        function loadVideoList() {
            fetch('/api/videos').then(r => r.json()).then(data => {
                const listDiv = document.getElementById('videoList');
                if (data.videos.length === 0) {
                    listDiv.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">暂无视频文件</div>';
                    return;
                }
                
                let html = '';
                for (const video of data.videos) {
                    const sizeMB = (video.size / 1024 / 1024).toFixed(1);
                    const date = new Date(video.mtime * 1000).toLocaleString('zh-CN');
                    html += `
                        <div class="video-item" onclick="playVideo('${video.name}')">
                            <div class="video-item-name">${video.name}</div>
                            <div class="video-item-info">${sizeMB} MB | ${date}</div>
                        </div>
                    `;
                }
                listDiv.innerHTML = html;
            });
        }
        
        function playVideo(filename) {
            const container = document.getElementById('videoPlayerContainer');
            container.innerHTML = `
                <video id="videoPlayer" controls>
                    <source src="/api/video/${encodeURIComponent(filename)}" type="video/mp4">
                    您的浏览器不支持视频播放
                </video>
            `;
        }
        
        // 页面加载时获取视频列表
        loadVideoList();
        // 每30秒刷新一次视频列表
        setInterval(loadVideoList, 30000);
    </script>
</body>
</html>
'''

@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

def ros_spin():
    """ROS spin线程"""
    rclpy.spin(ros_node)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--port', type=int, default=5000, help='Flask服务端口')
    args = parser.parse_args()
    
    global ros_node
    rclpy.init()
    ros_node = WebVisualizerNode()
    
    # 启动ROS spin线程
    ros_thread = threading.Thread(target=ros_spin, daemon=True)
    ros_thread.start()
    
    print(f"[INFO] Web可视化服务已启动")
    print(f"[INFO] 访问地址: http://0.0.0.0:{args.port}")
    
    # 启动Flask
    socketio.run(app, host='0.0.0.0', port=args.port, debug=False, allow_unsafe_werkzeug=True)

if __name__ == '__main__':
    main()
